{"meta":{"title":"x:xs","subtitle":null,"description":null,"author":"jdkim","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"googletest","slug":"googletest","date":"2017-05-18T06:19:48.000Z","updated":"2017-05-18T09:30:34.000Z","comments":true,"path":"2017/05/18/googletest/","link":"","permalink":"http://yoursite.com/2017/05/18/googletest/","excerpt":"","text":"https://github.com/google/googletest/blob/master/googletest/docs/V1_7_Primer.md Introduction: Why Google C++ Testing Framework? 좋은 테스트란? 독립적, 반복적 - 다른 테스트의 결과에 따라 결과가 바뀌면 디버깅 하기 어렵다. gtest 는, 각 테스트를 다른 객체를 통해 수행하는 방법으로 고립 시킨다. 빠른 디버깅을 위해 실패한 테스트만 고립시켜서 실행 할 수 있다. 테스트들은 잘 조직화 되고, 테스트 대상이 되는 코드의 구조를 반영하는 것이 좋다. gtest 는, 관련된 테스트들을 테스트 케이스로 묶고, 데이터와 서브 루틴을 공유할 수 있다. 테스트의 이식성과 재사용성 - 오픈 소스 커뮤니티는 플랫폼 중립적인 코드가 많고, 테스트 역시 플랫폼 중립적인 것이 좋다. gtest 는, 다른 os, 컴파일러로 쉽게 동작 할 수 있다. 테스트가 실패하면, 가능한한 문제에 대한 많은 정보를 제공하는 것이 좋다. gtest 는, 테스트 실패시 현재 테스트만 중단하고, 다음 테스트는 계속 수행 한다. 설정을 통해 실패시 치명적인 오류가 아닌 경우 리포트하고 계속 수행하도록 할 수 있다. 한번의 실행-편집-컴파일 주기를 통해 많은 결함을 찾아 수정할 수 있다. 테스트 작성자가 테스트 자체에 대해서만 집중할 수 있도록 하는 것이 좋다. gtest 는, 정의된 테스트들을 모두 알고 있고, 실행을 위해서 모두 나열하지 않아도 된다. 테스트 실행이 빨라야 한다. gtest 는, set-up/tear-down 을 한번만 수행하고, 리소스를 테스트들 간에 공유할 수 있어 다른 테스트를 기다릴 필요가 없다. Setting up a New Test Project테스트 프로그램 작성을 위해서는, gtest 를 라이브러리로 컴파일 하고, 테스트와 링크 해야 한다.gtest 루트 디렉토리 아래 인기있는 빌드 시스템 위한 빌드 파일들을 제공한다. (msvc, xcode, make, codegear, CMakeLists.txt)해당되는 빌드 시스템이 없다면, make/Makefile 에서 컴파일 하는 방법을 찾을 수 있다. (기본적으로 src/gtest-all.cc 를 컴파일 하며, 헤더 검색 결로에 GTEST_ROOT, GTEST_ROOT/include 를 포함시킨다.)테스트를 위한 빌드 타겟을 만들고, GTEST_ROOT/include 를 헤더 검색 경로에 포함하고 gtest 라이브러리르 링크 하도록 설정한다. Basic Concepts보통은 assertion 문을 사용해서 조건이 참인자 체크 한다.assertion 의 결과는 success, nonfatal failure, fatal failure 가 될 수 있다.fatal failure 면 현재 함수를 종료하고, 그렇지 않으면 계속 수행한다. ‘테스트’ 는 테스트 대상 코드의 행위를 검중하기 위해 assertion 을 사용하며, 테스트가 죽거나 assertion 이 실패하면, 실패이고 그렇지 않으면 성공 이다. ‘테스트 케이스’ 는 하나 혹은 여러 개으 테스트를 포함한다. 테스트 대상 코드의 구조를 반영 하도록 테스트들을 테스트 케이스로 묶는 것이 좋다.테스트 케이스에 있는 테스트들 간에 공유하는 공통 객체나 서브 루틴은 test fixture 클래스에 넣을 수 있다. ‘테스트 프로그램’ 은 여러 개의 테스트 케이스들을 포함 할 수 있다. Assertionsgtest 의 assertion 은 함수 호출 형태의 매크로들 이다.클래스나 함수에 대해 assertion 을 만들어서 테스트 할 수 있다. 실패 하면, 소스 파일명과 줄 수, 실패 메세지를 출력 해준다.gtest 메세지에 추가되는 커스텀 실패 메세지도 넣을 수 있다. assertion 종류에 따라 현재 함수에 다른 영향을 줄 수 있다. ASSERT_* - 실패하면 fatal failures 를 생성하고, 현재 함수를 종료 한다. EXPECT_* - nonfatal failures 를 생성하고, 종료하진 않는다. 테스트에서 여러개의 실패가 발생할 수 있으면, EXPECT_* 를 선호한다. 실패 했을 때, 더 이상 테스트를 진행하는 것이 의미가 없다면, ASSERT_* 을 사용한다. ASSERT_* 실패시, 바로 현재 함수를 종료하기 때문에, 이후에 있을 만한 clean-up 코드는 실행되지 않을 수 있으며,space leak 을 유발할 수 도 있다. leak 의 특성에 따라 수정할 필요가 있거나 없을 수도 있다.assertion 에러 이외에 heak checker 에러가 발생하면, 이 부분을 고려하는 것이 좋다. 커스텀 실패 메세지를 추가 하려면, 매크로에 &lt;&lt; 연산자를 사용하면 된다. 연속해서 사용해도 된다. 12345ASSERT_EQ(x.size(), y.size()) &lt;&lt; \"Vectors x and y are of unequal length\";for (int i = 0; i &lt; x.size(); ++i) &#123; EXPECT_EQ(x[i], y[i]) &lt;&lt; \"Vectors x and y differ at index \" &lt;&lt; i;&#125; ostream 으로 보낼 수 있으면, 매크로로 보낼 수 있다. (c 문자열이나 string 객체)wide string (wchar_t, TCHAR in UNICODE mode on Windows, std::wstring)을 매크로로 보내면, UTF-8 로 변환되서 출력 된다. Basic Assertions이 assertion 들은 기본적인 true/false 조건 테스트를 할 수 있다.기억할 것은 ASSERT* 은 fatal failure 를 생성하고 현재 함수를 빠져 나가며, EXPECT* 는 nonfatal failure 를 생성하고 계속 진행한다는 것이다. Fatal assertion Nonfatal assertion Verifies ASSERT_TRUE(condition); EXPECT_TRUE(condition); condition is true ASSERT_FALSE(condition); EXPECT_FALSE(condition); condition is false Binary Comparison두 값을 비교하는 assertion 을 설명한다. Fatal assertion Nonfatal assertion Verifies ASSERT_EQ(expected,actual); EXPECT_EQ(expected,actual); expected == actual ASSERT_NE(val1,val2); EXPECT_NE(val1,val2); val1 != val2 ASSERT_LT(val1,val2); EXPECT_LT(val1,val2); val1 &lt; val2 ASSERT_LE(val1,val2); EXPECT_LE(val1,val2); val1 &lt;= val2 ASSERT_GT(val1,val2); EXPECT_GT(val1,val2); val1 &gt; val2 ASSERT_GE(val1,val2); EXPECT_GE(val1,val2); val1 &gt;= val2","categories":[],"tags":[]},{"title":"Curiously Recurring Template Pattern","slug":"Curiously-Recurring-Template-Pattern","date":"2017-05-16T14:53:27.000Z","updated":"2017-05-24T14:44:17.000Z","comments":true,"path":"2017/05/16/Curiously-Recurring-Template-Pattern/","link":"","permalink":"http://yoursite.com/2017/05/16/Curiously-Recurring-Template-Pattern/","excerpt":"","text":"가상함수를 통한 다형성 dynamic polymorphism or runtime polymorphism 일반적인 구현 방법 : 가상함수가 선언된 클래스의 객체에 숨겨진 포인터 추가 (실제 호출되는 함수의 객체에 대한 포인터) 실행시간 비용이 있음. Extra indirection (포인터 역참조) : 가상함수 호출시 마다 발생. inline 불가 : 작은 함수일 경우 비용이 증가함. 객체당 포인터 추가 : 64bit 를 주로 쓰는 요즘 8바이트 차지. 작은 객체의 경우 overhead 가 큼. 성능이 중요한 경우 가상함수 사용을 지양함. 대안은? 추가 비용 없이 template 으로 구현 가능. (There’s a catch, of course) static polymorphism or simulated dynamic binding 컴파일 타임에 호출 대상 객체가 결정됨. 이 방식의 핵심 -&gt; 파생 클래스의 타입이 기본 클래스의 타입 파라미터로 사용됨. 이렇게 함으로써, 컴파일 타임에 파생 클래스의 타입을 기본 클래스에 inject 한다. 컴파일 타임에 타입을 알 수 있기 때문에, static_cast 를 사용해서 this 를 파생 클래스 타입으로 변환 가능.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct TreeNode &#123; enum Kind &#123; RED, BLUE &#125;; TreeNode(Kind kind_, TreeNode *left_ = NULL, TreeNode *right_ = NULL) : kind(kind_), left(left_), right(right_) &#123;&#125; Kind kind; TreeNode *left, *right;&#125;;template &lt;typename Derived&gt; class GenericVisitor &#123;public: void visit_preorder(TreeNode *node) &#123; if (node) &#123; dispatch_node(node); visit_preorder(node-&gt;left); visit_preorder(node-&gt;right); &#125; &#125; void visit_inorder(TreeNode *node) &#123; if (node) &#123; visit_inorder(node-&gt;left); dispatch_node(node); visit_inorder(node-&gt;right); &#125; &#125; void visit_postorder(TreeNode *node) &#123; if (node) &#123; visit_postorder(node-&gt;left); visit_postorder(node-&gt;right); dispatch_node(node); &#125; &#125; void handle_RED(TreeNode *node) &#123; cerr &lt;&lt; \"Generic handle RED\\n\"; &#125; void handle_BLUE(TreeNode *node) &#123; cerr &lt;&lt; \"Generic handle BLUE\\n\"; &#125;private: // Convenience method for CRTP Derived &amp;derived() &#123; return *static_cast&lt;Derived *&gt;(this); &#125; void dispatch_node(TreeNode *node) &#123; switch (node-&gt;kind) &#123; case TreeNode::RED: derived().handle_RED(node); break; case TreeNode::BLUE: derived().handle_BLUE(node); break; default: assert(0); &#125; &#125;&#125;;// 간단한 파생 클래스.class SpecialVisitor : public GenericVisitor&lt;SpecialVisitor&gt; &#123; public: void handle_RED(TreeNode* node) &#123; cerr &lt;&lt; \"RED is special\\n\"; &#125;&#125;; 설명 여러 방식의 방문 로직은 기본 클래스에서 제공하고, 특정 노드에 대한 처리는 파생 클래스에서 처리. 소스 코드가 다른 종류의 노드를 갖는 트리로 생성되는, 컴파일러와 같은 코드에서 유용함. 컴파일러의 각 단계에서 필요한 visitor 를 구현해서 사용. Clang compiler frontend - RecursiveASTVisitor 다른 예제:123456789101112131415161718192021222324252627282930313233template &lt;typename Derived&gt;struct Comparisons &#123;&#125;;template &lt;typename Derived&gt;bool operator==(const Comparisons&lt;Derived&gt;&amp; o1, const Comparisons&lt;Derived&gt;&amp; o2) &#123; const Derived&amp; d1 = static_cast&lt;const Derived&amp;&gt;(o1); const Derived&amp; d2 = static_cast&lt;const Derived&amp;&gt;(o2); return !(d1 &lt; d2) &amp;&amp; !(d2 &lt; d1);&#125;template &lt;typename Derived&gt;bool operator!=(const Comparisons&lt;Derived&gt;&amp; o1, const Comparisons&lt;Derived&gt;&amp; o2) &#123; return !(o1 == o2);&#125;// 파생 클래스, '&lt;' 연산자만 구현.class Person : public Comparisons&lt;Person&gt; &#123; public: Person(string name_, unsigned age_) : name(name_), age(age_) &#123;&#125; friend bool operator&lt;(const Person&amp; p1, const Person&amp; p2); private: string name; unsigned age;&#125;;bool operator&lt;(const Person&amp; p1, const Person&amp; p2) &#123; return p1.age &lt; p2.age;&#125; 설명 ‘&lt;’ 연산자만 정의한 파생 클래스에서, ==, != 연산자를 사용할 수 있게 됨. Comparisons 과 같은 클래스를 mixin class 라고도 함. In object-oriented programming languages, a mixin is a class that provides a certain functionality to be inherited or just reused by a subclass, while not meant for instantiation (the generation of objects of that class). Inheriting from a mixin is not a form of specialization but is rather a means of collecting functionality. A class may inherit most or all of its functionality from one or more mixins through multiple inheritance. - Wikipedia quote mixin 특정 기능을 제공하는 클래스. 상속 받거나 단순하게 재사용함. (mixin 클래스의 객체 생성을 의미하지 않음) mixin 클래스 상속은 기능을 포함하는 방법이지, 구체화를 위한 것이 아니다. 다중 상속을 통해, 여러 mixin 클래스를 상속할 수 도 있다. CRTP 는 얼마나 쓸까? RecursiveASTVisitor in clang Iterator Facade in Boost iterator_facade is a base class template that implements the interface of standard iterators in terms of a few core functions and associated types, to be supplied by a derived iterator class. CWindowImpl template in Microsoft’s Active Template Library (ATL) enable_shared_from_this 참고 The Curiously Recurring Template Pattern in C++ by Eli Bendersky. More C++ Idioms","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"More C++ Idioms","slug":"More-C-Idioms","permalink":"http://yoursite.com/tags/More-C-Idioms/"}]},{"title":"constexpr","slug":"constexpr","date":"2017-05-16T14:33:24.000Z","updated":"2017-05-16T15:54:02.000Z","comments":true,"path":"2017/05/16/constexpr/","link":"","permalink":"http://yoursite.com/2017/05/16/constexpr/","excerpt":"","text":"향목 15: 가능하면 항상 constexpr을 사용하라 효과 컴파일 시점에 상수를 요구하는 문맥(정수 상수 표현식 integral constant expression)에 사용할 수 있다. 배열의 크기, 정수 템플릿 인수(std::array 의 길이), 열거자 값 그렇지 않은 경우도 사용 가능하다.. 는 것이 장점! const 객체는 반드시 컴파일 시점에 알려지는 값으로 초기화 되지 않음. 123int sz;const auto arraySize = sz; // okstd::array&lt;int, arraySize&gt; data; // error constexpr 함수의 경우, 컴파일 시점 상수를 인수로 호출될 경우만 상수가 된다. 이 경우, 컴파일 시점 상수를 요구하는 문맥에 쓸 수 있다. 상수가 아닌 경우도 쓸 수 있어서, 두 가지 버전을 따로 구현할 필요가 없어진다.","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"EMC++","slug":"EMC","permalink":"http://yoursite.com/tags/EMC/"}]},{"title":"algebraic hierarchy","slug":"algebraic-hierarchy","date":"2017-01-31T01:42:01.000Z","updated":"2017-01-31T06:02:53.000Z","comments":true,"path":"2017/01/31/algebraic-hierarchy/","link":"","permalink":"http://yoursite.com/2017/01/31/algebraic-hierarchy/","excerpt":"","text":"의도밀접하게 관련 있는 여러 개의 대수적 추상들(abstractions, 예. numbers)을 하나의 포괄적인(generic) 추상 뒤로 숨기고, 그것에 대한 포괄적인 인터페이스를 제공 한다. 동기방법참고","categories":[],"tags":[]},{"title":"address of","slug":"address-of","date":"2017-01-27T12:56:31.000Z","updated":"2017-01-31T06:04:49.000Z","comments":true,"path":"2017/01/27/address-of/","link":"","permalink":"http://yoursite.com/2017/01/27/address-of/","excerpt":"","text":"의도&amp; 연산자를 오버로딩한 주소 찾기. 동기논쟁이 될 소지가 있는게, 주소를 얻지 못하게 하려는 의도가 있을 수 도 있다.그럼에도 불구하고 언어에서는 가능하다. 12345678910111213class nonaddressable &#123;public: typedef double useless_type;private: useless_type operator&amp;() const;&#125;;int main()&#123; nonaddressable na; nonaddressable * naptr = &amp;na; // Compiler error here.&#125; 방법 const, volatile 한정자를 고려하여, 연산자를 오버로딩 할 수 없는 타입으로 변환 (reinterpret_cast) 상수성 제거 (const_cast) 다시 원래 타입으로 형 변환 (reinterpret_cast) 1234567891011template &lt;class T&gt;T * addressof(T &amp; v)&#123; return reinterpret_cast&lt;T *&gt;(&amp; const_cast&lt;char&amp;&gt; (reinterpret_cast&lt;const volatile char &amp;&gt;(v)));&#125;int main()&#123; nonaddressable na; nonaddressable * naptr = addressof(na); // No more compiler error.&#125; c++ 11 에서는 std::addressof 가 있음. 참고 원문 : Address Of Implementation of addressof C/C++ volatile 키워드","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"More C++ Idioms","slug":"More-C-Idioms","permalink":"http://yoursite.com/tags/More-C-Idioms/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-01-23T16:11:46.000Z","updated":"2017-01-23T16:11:46.000Z","comments":true,"path":"2017/01/24/hello-world/","link":"","permalink":"http://yoursite.com/2017/01/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}